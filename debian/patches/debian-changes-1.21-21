Index: astmanproxy-1.21/src/proxyfunc.c
===================================================================
--- astmanproxy-1.21.orig/src/proxyfunc.c	2012-03-08 16:42:19.000000000 +0000
+++ astmanproxy-1.21/src/proxyfunc.c	2012-03-08 16:42:19.000000000 +0000
@@ -363,8 +363,9 @@
 		indexed on UniqueID.
    If SrcUniqueID / DestUniqueID are present, store against both.
    If a record already exists, do nothing.
-   withbody = 1, saves a copy of whole message (server).
    withbody = 0, saves just the key (client).
+   withbody = 1, saves a copy of whole message (server).
+   withbody = 2, saves a copy of a newstate message (server).
 */
 int do_AddToStack(char *uniqueid, struct message *m, struct mansession *s, int withbody)
 {
@@ -378,23 +379,35 @@
 	while( t ) {
 		if( !strncmp( t->uniqueid, uniqueid, sizeof(t->uniqueid) ) )
 		{
-			pthread_mutex_unlock(&s->lock);
-			return 0;
+			if( withbody < 2 ) {
+				// Already added
+				pthread_mutex_unlock(&s->lock);
+				return 0;
+			} else
+				// Found record to update
+				break;
 		}
 		prev = t;
 		t = t->next;
 	}
+	if( !t && withbody == 2 ) {
+		// No record found to update.
+		pthread_mutex_unlock(&s->lock);
+		return 0;
+	}
 	if( s->depth >= MAX_STACK ) {
 		struct mstack *newtop;
 
 		newtop = s->stack->next;
 		if( s->stack->message )
 			free( s->stack->message );
+		if( s->stack->state )
+			free( s->stack->state );
 		free( s->stack );
 		s->stack = newtop;
 		s->depth--;
 	}
-	if( (t = malloc(sizeof(struct mstack))) ) {
+	if( !t && (t = malloc(sizeof(struct mstack))) ) {
 		memset(t, 0, sizeof(struct mstack));
 		strncpy( t->uniqueid, uniqueid, sizeof(t->uniqueid) );
 		s->depth++;
@@ -402,28 +415,42 @@
 			prev->next = t;
 		else
 			s->stack = t;
+	}
+	if( t ) {
+		char *msg = NULL;
 		if( withbody ) {
 			// Save the message, in a reduced form to save memory...
 			int m_size;
 			int i, j;
+
 			m_size = 1;
 			j = 0;
 			for( i = 0; i < m->hdrcount; i++ ) {
 				m_size += strlen(m->headers[i])+1;
 			}
-			if( m_size < MAX_STACKDATA && (t->message = malloc(m_size)) ) {
-				memset(t->message, 0, m_size);
+			if( m_size < MAX_STACKDATA && (msg = malloc(m_size)) ) {
+				memset(msg, 0, m_size);
+				if( withbody == 1 )
+					t->message = msg;
+				else {
+					if( t->state )
+						free( t->state );
+					t->state = msg;
+				}
 				for( i = 0; i < m->hdrcount; i++ ) {
-					strncpy( t->message + j, m->headers[i], m_size - j );
-					*(t->message + j + strlen(m->headers[i])) = '\n';
+					strncpy( msg + j, m->headers[i], m_size - j );
+					*(msg + j + strlen(m->headers[i])) = '\n';
 					j += strlen(m->headers[i]) + 1;
 				}
 			}
 		}
 		if( debug ) {
-			debugmsg("Added uniqueid: %s to %s stack", uniqueid, withbody?"server":"client");
-			if( t->message)
-				debugmsg("Cached message: %s", t->message);
+			if( withbody < 2 )
+				debugmsg("Added uniqueid: %s to %s stack", uniqueid, withbody?"server":"client");
+			else
+				debugmsg("Newstate for uniqueid: %s to %s stack", uniqueid, withbody?"server":"client");
+			if( withbody && msg )
+				debugmsg("Cached message: %s", msg);
 		}
 	}
 	pthread_mutex_unlock(&s->lock);
@@ -448,15 +475,27 @@
 	if( uniqueid[0] != '\0' ) {
 		if( do_AddToStack(uniqueid, m, s, withbody) )
 			ret |= ATS_SRCUNIQUE;
-	} else
-		absent++;
+	} else {
+		uniqueid = astman_get_header(m, "Uniqueid1");
+		if( uniqueid[0] != '\0' ) {
+			if( do_AddToStack(uniqueid, m, s, withbody) )
+				ret |= ATS_SRCUNIQUE;
+		} else
+			absent++;
+	}
 
 	uniqueid = astman_get_header(m, "DestUniqueID");
 	if( uniqueid[0] != '\0' ) {
 		if( do_AddToStack(uniqueid, m, s, withbody) )
 			ret |= ATS_DSTUNIQUE;
-	} else
-		absent++;
+	} else {
+		uniqueid = astman_get_header(m, "Uniqueid2");
+		if( uniqueid[0] != '\0' ) {
+			if( do_AddToStack(uniqueid, m, s, withbody) )
+				ret |= ATS_DSTUNIQUE;
+		} else
+			absent++;
+	}
 
 	if( s->user.more_events[0] != '\0' && absent == 3 )
 		ret = 1;	// Want more/anonymous events
@@ -551,8 +590,9 @@
 
 /* ResendFromStack - We want to resend a cached message from the stack please...
  * Look for "uniqueid" in cache of session "s", and reconstruct into message "m"
+ * If a Newstate has been seen, it gets put into "m2"
  */
-void ResendFromStack(char* uniqueid, struct mansession *s, struct message *m)
+void ResendFromStack(char* uniqueid, struct mansession *s, struct message *m, struct message *m2)
 {
 	struct mstack *t;
 
@@ -581,6 +621,17 @@
 				}
 			}
 			m->hdrcount = h;
+			for( i=0,h=0,j=0; i < strlen(t->state) && i < MAX_STACKDATA - 1 && h < MAX_HEADERS - 1; i++ ) {
+				if( t->state[i] == '\n' || i-j >= MAX_LEN ) {
+					strncpy( m2->headers[h], t->state + j, i-j );
+					m2->headers[h][MAX_LEN-1] = '\0';
+					j = i + 1;
+					if( debug )
+						debugmsg("remade: %s", m2->headers[h]);
+					h++;
+				}
+			}
+			m2->hdrcount = h;
 			pthread_mutex_unlock(&s->lock);
 			return;
 		}
@@ -602,8 +653,10 @@
 	char *account;
 	char *uniqueid;
 	char *tmp;
+	char *unmatched;
 	char *cheaders[] = {"Channel","Channel1","Channel2","Source","Destination","DestinationChannel","ChannelCalling",NULL};
-	int i, cmatched, cfound;
+	char *uheaders[] = {"UniqueID","Uniqueid1","Uniqueid2","SrcUniqueId","DestUniqueID",NULL};
+	int i, cmatched, cfound, ufound;
 
 	if( debug > 5 )
 		debugmsg("ValidateAction called for fd: %d, %s", s->fd, inbound?"inbound":"outbound");
@@ -674,28 +727,48 @@
 		return 0;
 	}
 
-	uniqueid = astman_get_header(m, "Uniqueid");
-	if( uniqueid[0] != '\0' && IsInStack(uniqueid, s) ) {
-		if( debug )
-			debugmsg("Message validated (uniqueid): %s already allowed", uniqueid);
-		if( !strcasecmp( event, "Hangup" ) )
-			DelFromStack(m, s);
-		return 1;
-	}
-	uniqueid = astman_get_header(m, "Uniqueid1");
-	if( uniqueid[0] != '\0' && IsInStack(uniqueid, s) ) {
-		if( debug )
-			debugmsg("Message validated (uniqueid1): %s already allowed", uniqueid);
-		if( !strcasecmp( event, "Hangup" ) )
-			DelFromStack(m, s);
-		return 1;
+	unmatched = "";
+	ufound = 0;
+	for( i=0; uheaders[i] != NULL; i++ ) {
+		uniqueid = astman_get_header(m, uheaders[i]);
+		if( uniqueid[0] != '\0' && IsInStack(uniqueid, s) ) {
+			if( debug )
+				debugmsg("Message validated (%s): %s already allowed", uheaders[i], uniqueid);
+			if( !strcasecmp( event, "Hangup" ) )
+				DelFromStack(m, s);
+			ufound = 1;
+		} else if( *uniqueid ) {
+			if( debug > 6 )
+				debugmsg("UniqueID: %s not matched for this connection.", uniqueid);
+			unmatched = uniqueid;
+		}
 	}
-	uniqueid = astman_get_header(m, "Uniqueid2");
-	if( uniqueid[0] != '\0' && IsInStack(uniqueid, s) ) {
-		if( debug )
-			debugmsg("Message validated (uniqueid2): %s already allowed", uniqueid);
-		if( !strcasecmp( event, "Hangup" ) )
-			DelFromStack(m, s);
+	if( ufound ) {
+		if( *unmatched == '\0' ) {
+			if( debug > 4 )
+				debugmsg("-- No unmatched header found.");
+			return 1;
+		}
+		if( *uchannel == '\0' ) {
+			if( debug > 4 )
+				debugmsg("-- chan filtering not enabled.");
+			return 1;
+		}
+
+	// We are allowing based on UID, but also have an unmatched UID
+	// If Channel matches, then also add that UID.
+		for( i=0; cheaders[i] != NULL; i++ ) {
+			channel = astman_get_header(m, cheaders[i]);
+			if( channel[0] == '\0' )
+				continue;	// No header by that name.
+			if( !strncasecmp( channel, uchannel, strlen(uchannel) )) {	// We have a Channel: header, so save the UID
+				if( debug > 4 )
+					debugmsg("-- Chan match, adding secondary UniqueID: %s", unmatched);
+				return AddToStack(m, s, 0) | 1;
+			}
+		}
+		if( debug > 4 )
+			debugmsg("-- No Chan match, NOT adding secondary UniqueID: %s", unmatched);
 		return 1;
 	}
 
@@ -795,6 +868,10 @@
 
 	// Outbound or unfiltered packets are validated.
 	if( !inbound || (uchannel[0] == '\0' && ucontext[0] == '\0') ) {
+		if( debug > 2 && !inbound )
+			debugmsg("Validate Passing an outbound message.");
+		if( debug > 2 && (uchannel[0] == '\0' && ucontext[0] == '\0') )
+			debugmsg("Validate Passing msg with no context or channel filter.");
 		return 1;
 	}
 
Index: astmanproxy-1.21/src/astmanproxy.c
===================================================================
--- astmanproxy-1.21.orig/src/astmanproxy.c	2012-03-08 16:42:19.000000000 +0000
+++ astmanproxy-1.21/src/astmanproxy.c	2012-03-08 16:42:19.000000000 +0000
@@ -24,7 +24,7 @@
 extern int  AddToStack(struct message *m, struct mansession *s, int withbody);
 extern void DelFromStack(struct message *m, struct mansession *s);
 extern void FreeStack(struct mansession *s);
-extern void ResendFromStack(char* uniqueid, struct mansession *s, struct message *m);
+extern void ResendFromStack(char* uniqueid, struct mansession *s, struct message *m, struct message *m2);
 
 int ConnectAsterisk(struct mansession *s);
 
@@ -202,7 +202,10 @@
 	if( !strcasecmp( event, "Newchannel" ) ) {
 		AddToStack(m, m->session, 1);
 		is_nc = 1;	// Make sure we don't resend it from Stack.
-	}
+	} else if( !strcasecmp( event, "Newstate" ) ) {
+                AddToStack(m, m->session, 2);
+                is_nc = 1;      // Make sure we don't resend it from Stack.
+        }
 	while (c) {
 		if ( c->server || m->hdrcount<2 ) {
 			if( debug > 4 && c->server )
@@ -223,7 +226,8 @@
 	// Original AutoFilter
 				autofilter = 1;
 			else if ( c->autofilter == 2 && *actionid == '\0' )
-				autofilter = 1;
+	// No actionID, so filter does not apply.
+				autofilter = -1;
 			else if ( c->autofilter == 2 && !strncmp(actionid, c->actionid, strlen(c->actionid)) ) {
 	// New AutoFilter, actionid like "ast123-XX"
 				memmove( actionid, actionid+strlen(c->actionid), strlen(actionid)+1-strlen(c->actionid));
@@ -242,27 +246,52 @@
 				debugmsg("Validate allowed a message to a client, ret=%d", valret);
  			if( (valret & ATS_UNIQUE) && m->session && !is_nc ) {
 				struct message m_temp;
-				memset(&m_temp, 0, sizeof(struct message) );
+				struct message m_temp2;
+			        m_temp.hdrcount=0;
+			        m_temp.in_command=0;
+			        m_temp.session=m->session;
+			        m_temp2.hdrcount=0;
+			        m_temp2.in_command=0;
+			        m_temp2.session=m->session;
 				uniqueid = astman_get_header(m, "UniqueID");
-				ResendFromStack(uniqueid, m->session, &m_temp);
-				m_temp.session = m->session;
+				ResendFromStack(uniqueid, m->session, &m_temp, &m_temp2);
 				c->output->write(c, &m_temp);
+				if( m_temp2.hdrcount )
+					c->output->write(c, &m_temp2);
  			}
  			if( (valret & ATS_SRCUNIQUE) && m->session ) {
 				struct message m_temp;
-				memset(&m_temp, 0, sizeof(struct message) );
+				struct message m_temp2;
+			        m_temp.hdrcount=0;
+			        m_temp.in_command=0;
+			        m_temp.session=m->session;
+			        m_temp2.hdrcount=0;
+			        m_temp2.in_command=0;
+			        m_temp2.session=m->session;
 				uniqueid = astman_get_header(m, "SrcUniqueID");
-				ResendFromStack(uniqueid, m->session, &m_temp);
-				m_temp.session = m->session;
+				if( *uniqueid == '\0' )
+					uniqueid = astman_get_header(m, "Uniqueid1");
+				ResendFromStack(uniqueid, m->session, &m_temp, &m_temp2);
 				c->output->write(c, &m_temp);
+				if( m_temp2.hdrcount )
+					c->output->write(c, &m_temp2);
  			}
  			if( (valret & ATS_DSTUNIQUE) && m->session ) {
 				struct message m_temp;
-				memset(&m_temp, 0, sizeof(struct message) );
+				struct message m_temp2;
+			        m_temp.hdrcount=0;
+			        m_temp.in_command=0;
+			        m_temp.session=m->session;
+			        m_temp2.hdrcount=0;
+			        m_temp2.in_command=0;
+			        m_temp2.session=m->session;
 				uniqueid = astman_get_header(m, "DestUniqueID");
-				ResendFromStack(uniqueid, m->session, &m_temp);
-				m_temp.session = m->session;
+				if( *uniqueid == '\0' )
+					uniqueid = astman_get_header(m, "Uniqueid2");
+				ResendFromStack(uniqueid, m->session, &m_temp, &m_temp2);
 				c->output->write(c, &m_temp);
+				if( m_temp2.hdrcount )
+					c->output->write(c, &m_temp2);
  			}
 			if( autofilter != 0 )
 				c->output->write(c, m);
Index: astmanproxy-1.21/src/include/astmanproxy.h
===================================================================
--- astmanproxy-1.21.orig/src/include/astmanproxy.h	2012-03-08 16:42:19.000000000 +0000
+++ astmanproxy-1.21/src/include/astmanproxy.h	2012-03-08 16:42:19.000000000 +0000
@@ -116,6 +116,7 @@
 	struct mstack *next;
 	char uniqueid[80];
 	char *message;
+	char *state;
 };
 
 struct mansession {
