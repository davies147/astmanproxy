Description: <short summary of the patch>
 TODO: Put a short summary on the line above and replace this paragraph
 with a longer explanation of this change. Complete the meta-information
 with other relevant fields (see below for details). To make it easier, the
 information below has been extracted from the changelog. Adjust it or drop
 it.
 .
 astmanproxy (1.26-9) unstable; urgency=low
 .
   * Add FILT_ASTERIX mode
Author: root <steved@ipcortex.co.uk>

---
The information above should follow the Patch Tagging Guidelines, please
checkout http://dep.debian.net/deps/dep3/ to learn about the format. Here
are templates for supplementary fields that you might want to add:

Origin: <vendor|upstream|other>, <url of original patch>
Bug: <url in upstream bugtracker>
Bug-Debian: http://bugs.debian.org/<bugnumber>
Bug-Ubuntu: https://launchpad.net/bugs/<bugnumber>
Forwarded: <no|not-needed|url proving that it has been forwarded>
Reviewed-By: <name and email of someone who approved the patch>
Last-Update: <YYYY-MM-DD>

--- a/src/astmanproxy.c
+++ b/src/astmanproxy.c
@@ -25,6 +25,7 @@
 extern void DelFromStack(struct message *m, struct mansession *s);
 extern void FreeStack(struct mansession *s);
 extern void ResendFromStack(char* uniqueid, struct mansession *s, struct message *m, struct message *m2);
+extern struct message *do_asterix_filt(struct message *m);
 
 int ConnectAsterisk(struct mansession *s);
 
@@ -300,8 +301,19 @@
 				if( m_temp2.hdrcount )
 					c->output->write(c, &m_temp2);
  			}
-			if( autofilter != 0 )
-				c->output->write(c, m);
+			if( autofilter != 0 ) {
+				if ( c->user.filter_bits & FILT_ASTERIX ) {
+					/* do_asterix_filt() allocates and retuens a new message struct if necessary */
+					/* And can return NULL to indicate a discard */
+					struct message *res = do_asterix_filt(m);
+					if ( res ) {
+						c->output->write(c, res);
+						if ( res != m )
+							free(res);
+					}
+				} else
+					c->output->write(c, m);
+			}
 
 			if (c->inputcomplete) {
 				pthread_mutex_lock(&c->lock);
--- a/src/proxyfunc.c
+++ b/src/proxyfunc.c
@@ -759,7 +759,11 @@
 			}
 		}
 		if( s->user.filter_bits & FILT_NOVAR ) {
-			if( !strcasecmp( event, "SetVar" ) ) {
+			if( !strcasecmp( event, "Set" ) ) {
+				if( debug )
+					debugmsg("NOVAR set. Blocked Set");
+				return 0;
+			} else if( !strcasecmp( event, "SetVar" ) ) {
 				if( debug )
 					debugmsg("NOVAR set. Blocked SetVar");
 				return 0;
@@ -944,3 +948,46 @@
 
 	return 0;
 }
+
+extern struct message *do_asterix_filt(struct message *m) {
+	int i;
+	char *tmp;
+	struct message *res;
+	char *headers[] = {
+				"Response","Event","ActionID","Channeltype","ObjectName","ChanObjectType","IPaddress","IPport",
+				"Dynamic","Status","RegExpire","Address-IP","Address-Port","SIP-Useragent","Reg-Contact","VoiceMailbox",
+				NULL
+			};
+
+	tmp = astman_get_header(m, "ActionID");				/* Has no ActionID */
+	if( tmp[0] == '\0' )
+		return m;
+	tmp = astman_get_header(m, "ChannelType");			/* Has no ChannelType, or not 'SIP' */
+	if( tmp[0] == '\0' || strcmp( tmp, "SIP" ) )
+		return m;
+	tmp = astman_get_header(m, "ChanObjectType");			/* Has no ChanObjectType, or not 'peer' */
+	if( tmp[0] == '\0' || strcmp( tmp, "peer" ) )
+		return m;
+	tmp = astman_get_header(m, "Response");
+	if( tmp[0] == '\0' || strcmp( tmp, "Success" ) ) {		/* Not a Result: Success */
+		tmp = astman_get_header(m, "Event");
+		if( tmp[0] == '\0' || strcmp( tmp, "PeerEntry" ) )	/* And not an Event: PeerEntry */
+			return m;
+	}
+
+	/* Duplicate and modify (reduce) the original frame to save bandwidth */
+
+        if (! (res = malloc(sizeof(struct message))) )
+                return m;
+	res->hdrcount = 0;
+	res->in_command = 0;
+	res->session = m->session;
+	for( i=0; headers[i] != NULL; i++ ) {
+		tmp = astman_get_header(m, headers[i]);
+		if( tmp[0] == '\0' )
+			continue;	// No header by that name.
+		AddHeader(res, "%s: %s", headers[i], tmp);
+	}
+
+	return res;
+}
--- a/src/config_perms.c
+++ b/src/config_perms.c
@@ -82,6 +82,8 @@
 		user->filter_bits |= FILT_XFRONLY;
 	if( strcasestr(user->filters, FILT_TOK_NOVAR) )
 		user->filter_bits |= FILT_NOVAR;
+	if( strcasestr(user->filters, FILT_TOK_ASTERIX) )
+		user->filter_bits |= FILT_ASTERIX;
 
 	user->next = *pu;
 	*pu = user;
--- a/src/include/astmanproxy.h
+++ b/src/include/astmanproxy.h
@@ -70,12 +70,14 @@
 #define FILT_TOK_BRIONLY "brionly"
 #define FILT_TOK_XFRONLY "xfronly"
 #define FILT_TOK_NOVAR   "novar"
+#define FILT_TOK_ASTERIX "asterix"
 
 enum filters {
 	FILT_CDRONLY = (1 << 0),	/* Only pass CDR events. Nothing else (except other FILT_???ONLY). */
 	FILT_BRIONLY = (1 << 1),	/* Only pass Bridge events. Nothing else (except other FILT_???ONLY). */
 	FILT_XFRONLY = (1 << 2),	/* Only pass Transfer events. Nothing else (except other FILT_???ONLY). */
 	FILT_NOVAR =   (1 << 3),	/* Never send SetVar/VarSet events to this client */
+	FILT_ASTERIX = (1 << 4),	/* Asterix mode */
 };
 
 struct proxyconfig {
