--- astmanproxy-1.21.orig/src/common.c
+++ astmanproxy-1.21/src/common.c
@@ -18,14 +18,17 @@ int get_input(struct mansession *s, char
 {
 	/* output must have at least sizeof(s->inbuf) space */
 	int res;
-	int haveline = 0;
-	int x;
+	int haveline;
+	int x, y, xtra;
 	struct pollfd fds[1];
 	char iabuf[INET_ADDRSTRLEN];
 
 	/* Look for \r\n from the front, our preferred end of line */
-	for (x=s->inoffset; x < s->inoffset + s->inlen && x < s->inoffset + MAX_LEN - 1; x++) {
-		int xtra = 0;
+	haveline = 0;
+#define MIN(a,b) (a<b?a:b)
+	y = MIN(s->inoffset + s->inlen, s->inoffset + MAX_LEN - 1);
+	xtra = 0;
+	for (x=s->inoffset; x < y; x++) {
 		if (s->inbuf[x] == '\n') {
 			if (x > s->inoffset && s->inbuf[x-1] == '\r') {
 				xtra = 1;
@@ -43,14 +46,11 @@ int get_input(struct mansession *s, char
 	}
 	if( s->inlen == 0 )
 		s->inoffset = 0;
-	if( haveline == 1 && sizeof(s->inbuf) - 1 - s->inlen - s->inoffset < MAX_LEN )
-		return 1;
-	if( s->inoffset > (MAX_LEN_INBUF*3/4) || (s->inoffset > (MAX_LEN_INBUF/4) && MAX_LEN_INBUF - s->inlen - s->inoffset < (MAX_LEN_INBUF/4)) ) {
+	if( s->inoffset > (MAX_LEN_INBUF*3/4) || (s->inoffset > (MAX_LEN_INBUF/4) && MAX_LEN_INBUF - s->inlen - s->inoffset < MAX_LEN) ) {
 		memmove(s->inbuf, s->inbuf + s->inoffset, s->inlen);
 		s->inoffset = 0;
 		s->inbuf[s->inlen] = '\0';
 	}
-
 	if (s->inlen >= sizeof(s->inbuf) - 1) {
 		if (debug)
 			debugmsg("Warning: Got long line with no end from %s: %s\n", ast_inet_ntoa(iabuf, sizeof(iabuf), s->sin.sin_addr), s->inbuf);
@@ -58,6 +58,9 @@ int get_input(struct mansession *s, char
 		s->inoffset = 0;
 		s->inbuf[0] = '\0';
 	}
+	if( haveline == 1 && (MAX_LEN_INBUF - s->inlen - s->inoffset < MAX_LEN || *output != '\0') )
+		return 1;
+
 	/* get actual fd, even if a negative SSL fd */
 	fds[0].fd = get_real_fd(s->fd);
 
--- astmanproxy-1.21.orig/src/proxyfunc.c
+++ astmanproxy-1.21/src/proxyfunc.c
@@ -619,8 +619,32 @@ int ValidateAction(struct message *m, st
 	}
 
 	event = astman_get_header(m, "Event");
-	uniqueid = astman_get_header(m, "Uniqueid");
 
+	// Handle special filter flags before IsInStack checks
+	if( inbound && s->user.filter_bits & FILT_CDRONLY ) {
+		if( !strcasecmp( event, "CDR" ) ) {
+			if( debug )
+				debugmsg("CDRONLY set. Is a CDR. Allowed");
+			return 1;
+		} else {
+			if( debug )
+				debugmsg("CDRONLY set. Not a CDR. Blocked");
+			return 0;
+		}
+	}
+	if( inbound && s->user.filter_bits & FILT_NOVAR ) {
+		if( !strcasecmp( event, "SetVar" ) ) {
+			if( debug )
+				debugmsg("NOVAR set. Blocked SetVar");
+			return 0;
+		} else if( !strcasecmp( event, "VarSet" ) ) {
+			if( debug )
+				debugmsg("NOVAR set. Blocked VarSet");
+			return 0;
+		}
+	}
+
+	uniqueid = astman_get_header(m, "Uniqueid");
 	if( uniqueid[0] != '\0' && IsInStack(uniqueid, s) ) {
 		if( debug )
 			debugmsg("Message validated (uniqueid): %s already allowed", uniqueid);
@@ -661,25 +685,6 @@ int ValidateAction(struct message *m, st
 		}
 	}
 
-	// Handle special filter flags
-	if( inbound && s->user.filter_bits & FILT_CDRONLY ) {
-		if( !strcasecmp( event, "CDR" ) ) {
-			if( debug )
-				debugmsg("CDRONLY set. Is a CDR. Allowed");
-			return 1;
-		} else {
-			if( debug )
-				debugmsg("CDRONLY set. Not a CDR. Blocked");
-			return 0;
-		}
-	}
-	if( inbound && s->user.filter_bits & FILT_NOVAR ) {
-		if( !strcasecmp( event, "SetVar" ) )
-			return 0;
-		else if( !strcasecmp( event, "VarSet" ) )
-			return 0;
-	}
-
 	action = astman_get_header(m, "Action");
 	if( uchannel[0] != '\0' ) {
 		if( debug )
--- astmanproxy-1.21.orig/src/astmanproxy.c
+++ astmanproxy-1.21/src/astmanproxy.c
@@ -249,8 +249,7 @@ int WriteClients(struct message *m) {
 }
 
 int WriteAsterisk(struct message *m) {
-	int i;
-	char outstring[MAX_LEN], *dest;
+	char *dest;
 	struct mansession *u, *s, *first;
 
 	first = NULL;
@@ -283,16 +282,7 @@ int WriteAsterisk(struct message *m) {
 		return 1;
 
 	debugmsg("writing block to %s", s->server->ast_host);
-
-	pthread_mutex_lock(&s->lock);
-	for (i=0; i<m->hdrcount; i++) {
-		if (strcasecmp(m->headers[i], "Server:") ) {
-			sprintf(outstring, "%s\r\n", m->headers[i]);
-			ast_carefulwrite(s->fd, outstring, strlen(outstring), s->writetimeout );
-		}
-	}
-	ast_carefulwrite(s->fd, "\r\n", 2, s->writetimeout);
-	pthread_mutex_unlock(&s->lock);
+	s->output->write(s, m);
 	return 1;
 }
 
@@ -393,13 +383,16 @@ void *HandleAsterisk(struct mansession *
 		goto leave;
 	if (! (m = malloc(sizeof(struct message))) )
 		goto leave;
+	memset(m, 0, sizeof(struct message) );
 
 	// Signal settings are not always inherited by threads, so ensure we ignore this one
 	(void) signal(SIGPIPE, SIG_IGN);
 	for (;;) {
 		if (debug)
 			debugmsg("asterisk@%s: attempting read...", ast_inet_ntoa(iabuf, sizeof(iabuf), s->sin.sin_addr));
-		memset(m, 0, sizeof(struct message) );
+		m->hdrcount = 0;
+		m->in_command = 0;
+		m->session = (void*)0;
 		res = s->input->read(s, m);
 		m->session = s;
 
--- astmanproxy-1.21.orig/src/include/astmanproxy.h
+++ astmanproxy-1.21/src/include/astmanproxy.h
@@ -162,6 +162,7 @@ int StartServer(struct ast_server *srv);
 int WriteAsterisk(struct message *m);
 char *astman_get_header(struct message *m, char *var);
 int proxyerror_do(struct mansession *s, char *err);
+int get_input_block(struct mansession *s, struct message *m);
 int get_input(struct mansession *s, char *output);
 int SetIOHandlers(struct mansession *s, char *ifmt, char *ofmt);
 void destroy_session(struct mansession *s);
