Description: <short summary of the patch>
 TODO: Put a short summary on the line above and replace this paragraph
 with a longer explanation of this change. Complete the meta-information
 with other relevant fields (see below for details). To make it easier, the
 information below has been extracted from the changelog. Adjust it or drop
 it.
 .
 astmanproxy (1.26-13) unstable; urgency=low
 .
   * Try to clean up daed flags and locking some more.
Author: root <steved@ipcortex.co.uk>

---
The information above should follow the Patch Tagging Guidelines, please
checkout http://dep.debian.net/deps/dep3/ to learn about the format. Here
are templates for supplementary fields that you might want to add:

Origin: <vendor|upstream|other>, <url of original patch>
Bug: <url in upstream bugtracker>
Bug-Debian: http://bugs.debian.org/<bugnumber>
Bug-Ubuntu: https://launchpad.net/bugs/<bugnumber>
Forwarded: <no|not-needed|url proving that it has been forwarded>
Reviewed-By: <name and email of someone who approved the patch>
Last-Update: <YYYY-MM-DD>

--- astmanproxy-1.26.orig/src/standard.c
+++ astmanproxy-1.26/src/standard.c
@@ -54,6 +54,8 @@ int _write(struct mansession *s, struct
 	// Combine headers into a buffer for more effective network use.
 	// This can have HUGE benefits under load.
 	at = 0;
+	if ( s->dead )
+		return 0;
 	pthread_mutex_lock(&s->lock);
 
 	if (debug>2)
@@ -67,6 +69,10 @@ int _write(struct mansession *s, struct
 			if( at ) {
 				res = ast_carefulwrite(s, w_buf, at);
 				at = 0;
+				if ( res < 0 ) {
+					s->dead = 1;
+					break;
+				}
 			}
 		if( strlen(m->headers[i]) > 1480 ) {
 			res = ast_carefulwrite(s, m->headers[i], strlen(m->headers[i]));
@@ -86,7 +92,7 @@ int _write(struct mansession *s, struct
 		res = ast_carefulwrite(s, w_buf, at);
 		if ( res < 0 )
 			s->dead = 1;
-		}
+	}
 	pthread_mutex_unlock(&s->lock);
 
 	return 0;
--- astmanproxy-1.26.orig/src/common.c
+++ astmanproxy-1.26/src/common.c
@@ -79,15 +79,17 @@ int get_input(struct mansession *s, char
 				continue;
 			}
 			if (debug)
-				debugmsg("Select returned error");
+				debugmsg("Poll returned error");
 			return -1;
 		} else if (res > 0) {
 			pthread_mutex_lock(&s->lock);
 			/* read from socket; SSL or otherwise */
 			res = m_recv(s->fd, s->inbuf + s->inoffset + s->inlen, sizeof(s->inbuf) - s->inoffset - 1 - s->inlen, 0);
 			pthread_mutex_unlock(&s->lock);
-			if (res < 1)
+			if (res < 1) {
+/* TODO: Check errno, and set dead if needed? */
 				return -1;
+			}
 			break;
 
 		} /* else res == 0 : timeout */
--- astmanproxy-1.26.orig/src/astmanproxy.c
+++ astmanproxy-1.26/src/astmanproxy.c
@@ -175,14 +175,19 @@ void destroy_session(struct mansession *
 			prev->next = cur->next;
 		else
 			sessions = cur->next;
+		pthread_rwlock_unlock(&sessionlock);
+
 		debugmsg("Connection closed: %s", ast_inet_ntoa(iabuf, sizeof(iabuf), s->sin.sin_addr));
+		pthread_mutex_lock(&s->lock);
 		close_sock(s->fd);	/* close tcp/ssl socket */
 		FreeStack(s);
+		pthread_mutex_unlock(&s->lock);
 		pthread_mutex_destroy(&s->lock);
 		free(s);
-	} else if (debug)
+	} else if (debug) {
 		debugmsg("Trying to delete non-existent session %p?\n", s);
-	pthread_rwlock_unlock(&sessionlock);
+		pthread_rwlock_unlock(&sessionlock);
+	}
 
 	/* If there are no servers and no clients, why are we here? */
 	if (!sessions) {
@@ -438,13 +443,13 @@ void *session_do(struct mansession *s)
 		if (res > 0) {
 			/* Check for anything that requires proxy-side processing */
 			if (pc.key[0] != '\0' && !s->authenticated) {
-			key = astman_get_header(&m, "ProxyKey");
-			if (!strcmp(key, pc.key) ) {
-				pthread_mutex_lock(&s->lock);
-				s->authenticated = 1;
-				pthread_mutex_unlock(&s->lock);
-			} else
-				break;
+				key = astman_get_header(&m, "ProxyKey");
+				if (!strcmp(key, pc.key) ) {
+					pthread_mutex_lock(&s->lock);
+					s->authenticated = 1;
+					pthread_mutex_unlock(&s->lock);
+				} else
+					break;
 			}
 
 			proxyaction = astman_get_header(&m, "ProxyAction");
@@ -473,6 +478,7 @@ void *session_do(struct mansession *s)
 			break;
 	}
 
+	s->dead = 1;
 	destroy_session(s);
 	if (debug)
 		debugmsg("--- exiting session_do thread ---");
@@ -514,7 +520,7 @@ void *HandleAsterisk(struct mansession *
 				if ( !strcmp("Authentication accepted", astman_get_header(m, "Message")) ) {
 					s->connected = 1;
 					if (debug)
-					debugmsg("asterisk@%s: connected successfully!", ast_inet_ntoa(iabuf, sizeof(iabuf), s->sin.sin_addr) );
+						debugmsg("asterisk@%s: connected successfully!", ast_inet_ntoa(iabuf, sizeof(iabuf), s->sin.sin_addr) );
 				}
 				if ( !strcmp("Authentication failed", astman_get_header(m, "Message")) ) {
 					s->connected = -1;
@@ -524,7 +530,7 @@ void *HandleAsterisk(struct mansession *
 				if ( !strcmp("FullyBooted", astman_get_header(m, "Event")) ) {
 					s->connected = 2;
 					if (debug)
-					debugmsg("asterisk@%s: connected successfully!", ast_inet_ntoa(iabuf, sizeof(iabuf), s->sin.sin_addr) );
+						debugmsg("asterisk@%s: connected successfully!", ast_inet_ntoa(iabuf, sizeof(iabuf), s->sin.sin_addr) );
 				} else
 					continue;
 			}
@@ -547,6 +553,7 @@ void *HandleAsterisk(struct mansession *
 leave:
 	if (debug)
 		debugmsg("asterisk@%s: Giving up and exiting thread", ast_inet_ntoa(iabuf, sizeof(iabuf), s->sin.sin_addr) );
+	s->dead = 1;
 	destroy_session(s);
 	pthread_exit(NULL);
 	return NULL;
